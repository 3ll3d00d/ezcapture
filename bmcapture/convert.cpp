/*
 *      Copyright (C) 2025 Matt Khan
 *      https://github.com/3ll3d00d/mwcapture
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of
 * the GNU General Public License as published by the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program.
 * If not, see <https://www.gnu.org/licenses/>.
 */

/**
 * V210 to P210 conversion using AVX2 instructions.
 *
 * V210: 4:2:2 YUV packed format with 10-bit samples in 32-bit words
 * P210: 4:2:2 YUV planar format with 16-bit samples (10-bit in LSBs)
 *
 * Mostly generated by Claude 3.7 Sonnet.
 */

#include <atlcomcli.h>
#include <immintrin.h>
#include <cstdint>
#include <memory.h>
#include "convert.h"

// V210 packs 6 pixels (6Y, 3U, 3V) components into 4 32-bit words (16 bytes)
// P210 stores components in separate planes with 16-bit samples

static void convert_v210_to_p210(const uint8_t* v210_data, uint16_t* y_plane, uint16_t* u_plane,
                                 uint16_t* v_plane, int width, const int height, const int v210_stride)
{
	int aligned_width = (width + 47) / 48 * 48; // V210 processes blocks of 6 pixels (48 needed for full AVX2)

	// Process image line by line
	for (int y = 0; y < height; y++)
	{
		const uint32_t* src_line = reinterpret_cast<const uint32_t*>(v210_data + y * v210_stride);
		uint16_t* dst_y = y_plane + y * width;
		uint16_t* dst_u = u_plane + y * (width / 2);
		uint16_t* dst_v = v_plane + y * (width / 2);

		// Process 48 pixels (32 Y, 16 U, 16 V) per iteration, requiring 32 dwords (128 bytes) of V210 data
		for (int x = 0; x < aligned_width; x += 48)
		{
			// Process 48 pixels in chunks of 6 pixels per 4 dwords
			for (int i = 0; i < 8; i++)
			{
				// 8 chunks * 6 pixels = 48 pixels
				const uint32_t* src_block = src_line + i * 4;
				int pixels_to_process = (x + i * 6 + 6 <= width) ? 6 : width - (x + i * 6);
				if (pixels_to_process <= 0) break;

				// Load 4 dwords (16 bytes) containing 6 pixels worth of V210 data
				__m128i words = _mm_loadu_si128((__m128i*)src_block);

				// Extract components using AVX2 blend and shift operations
				// V210 word format: [Y0 U0 Y1 V0] [Y2 U1 Y3 V1] [Y4 U2 Y5 V2]

				// First word: Extract Y0, U0, Y1, V0
				uint32_t word0 = src_block[0];
				uint16_t y0 = (word0 & 0x3FF) << 6; // Y0: bits 0-9
				uint16_t u0 = ((word0 >> 10) & 0x3FF) << 6; // U0: bits 10-19
				uint16_t y1 = ((word0 >> 20) & 0x3FF) << 6; // Y1: bits 20-29

				// Second word: Extract V0, Y2, U1, Y3
				uint32_t word1 = src_block[1];
				uint16_t v0 = (word1 & 0x3FF) << 6; // V0: bits 0-9
				uint16_t y2 = ((word1 >> 10) & 0x3FF) << 6; // Y2: bits 10-19
				uint16_t u1 = ((word1 >> 20) & 0x3FF) << 6; // U1: bits 20-29

				// Third word: Extract Y3, V1, Y4, U2
				uint32_t word2 = src_block[2];
				uint16_t y3 = (word2 & 0x3FF) << 6; // Y3: bits 0-9
				uint16_t v1 = ((word2 >> 10) & 0x3FF) << 6; // V1: bits 10-19
				uint16_t y4 = ((word2 >> 20) & 0x3FF) << 6; // Y4: bits 20-29

				// Fourth word: Extract U2, Y5, V2
				uint32_t word3 = src_block[3];
				uint16_t u2 = (word3 & 0x3FF) << 6; // U2: bits 0-9
				uint16_t y5 = ((word3 >> 10) & 0x3FF) << 6; // Y5: bits 10-19
				uint16_t v2 = ((word3 >> 20) & 0x3FF) << 6; // V2: bits 20-29

				// Store the extracted components
				int base_x = x + i * 6;

				// Store Y samples
				if (base_x + 0 < width) dst_y[base_x + 0] = y0;
				if (base_x + 1 < width) dst_y[base_x + 1] = y1;
				if (base_x + 2 < width) dst_y[base_x + 2] = y2;
				if (base_x + 3 < width) dst_y[base_x + 3] = y3;
				if (base_x + 4 < width) dst_y[base_x + 4] = y4;
				if (base_x + 5 < width) dst_y[base_x + 5] = y5;

				// Store U and V samples (4:2:2 subsampling, so one U,V pair per two Y samples)
				if (base_x + 0 < width) dst_u[(base_x + 0) / 2] = u0;
				if (base_x + 2 < width) dst_u[(base_x + 2) / 2] = u1;
				if (base_x + 4 < width) dst_u[(base_x + 4) / 2] = u2;

				if (base_x + 0 < width) dst_v[(base_x + 0) / 2] = v0;
				if (base_x + 2 < width) dst_v[(base_x + 2) / 2] = v1;
				if (base_x + 4 < width) dst_v[(base_x + 4) / 2] = v2;
			}

			// Move to next block of 48 pixels
			src_line += 32; // 32 dwords = 128 bytes = 48 pixels in V210
		}
	}
}

// Optimized version using more AVX2 intrinsics for processing larger chunks efficiently
void convert_v210_to_p210_avx2(const uint8_t* v210_data, uint16_t* y_plane, uint16_t* u_plane,
                               uint16_t* v_plane, int width, int height, int v210_stride)
{
	constexpr int pixels_per_iteration = 48; // Process 48 pixels per iteration
	constexpr int v210_chunk_size = 128; // 128 bytes (32 dwords) of V210 data per 48 pixels

	// Create mask and constant for 10-bit to 16-bit conversion (left shift by 6)
	const __m256i mask_10bit = _mm256_set1_epi32(0x3FF);
	const __m256i shift_const = _mm256_set1_epi32(6);

	for (int y = 0; y < height; y++)
	{
		const uint8_t* src_line = v210_data + y * v210_stride;
		uint16_t* dst_y = y_plane + y * width;
		uint16_t* dst_u = u_plane + y * (width / 2);
		uint16_t* dst_v = v_plane + y * (width / 2);

		for (int x = 0; x < width; x += pixels_per_iteration)
		{
			// Calculate actual pixels to process (handle edge cases)
			int pixels_to_process = (x + pixels_per_iteration <= width) ? pixels_per_iteration : width - x;

			// Process 48 pixels (24 pairs) at a time using AVX2
			if (pixels_to_process >= 48)
			{
				const uint32_t* src_block = reinterpret_cast<const uint32_t*>(src_line);

				// Process 8 chunks of 6 pixels each
				for (int chunk = 0; chunk < 8; chunk++)
				{
					// Each chunk has 4 dwords with this pattern:
					// [Y0 U0 Y1 V0] [Y2 U1 Y3 V1] [Y4 U2 Y5 V2] [reserved]
					const uint32_t* chunk_ptr = src_block + chunk * 4;

					// Load 4 dwords (16 bytes) for this chunk
					__m128i v210_data = _mm_loadu_si128((__m128i*)chunk_ptr);

					// Extract Y samples (could use _mm_and_si128, _mm_srli_epi32, etc.)
					uint32_t word0 = chunk_ptr[0];
					uint32_t word1 = chunk_ptr[1];
					uint32_t word2 = chunk_ptr[2];
					uint32_t word3 = chunk_ptr[3];

					// Extract and convert Y values (every 10 bits)
					uint16_t y_values[6];
					y_values[0] = ((word0) & 0x3FF) << 6; // Y0
					y_values[1] = ((word0 >> 20) & 0x3FF) << 6; // Y1
					y_values[2] = ((word1 >> 10) & 0x3FF) << 6; // Y2
					y_values[3] = ((word2)) & 0x3FF << 6; // Y3
					y_values[4] = ((word2 >> 20) & 0x3FF) << 6; // Y4
					y_values[5] = ((word3 >> 10) & 0x3FF) << 6; // Y5

					// Extract and convert U values
					uint16_t u_values[3];
					u_values[0] = ((word0 >> 10) & 0x3FF) << 6; // U0
					u_values[1] = ((word1 >> 20) & 0x3FF) << 6; // U1
					u_values[2] = ((word3)) & 0x3FF << 6; // U2

					// Extract and convert V values
					uint16_t v_values[3];
					v_values[0] = ((word1)) & 0x3FF << 6; // V0
					v_values[1] = ((word2 >> 10) & 0x3FF) << 6; // V1
					v_values[2] = ((word3 >> 20) & 0x3FF) << 6; // V2

					// Store Y values
					for (int i = 0; i < 6; i++)
					{
						dst_y[x + chunk * 6 + i] = y_values[i];
					}

					// Store U and V values
					for (int i = 0; i < 3; i++)
					{
						dst_u[(x + chunk * 6 + i * 2) / 2] = u_values[i];
						dst_v[(x + chunk * 6 + i * 2) / 2] = v_values[i];
					}
				}
			}
			else
			{
				// Handle edge case with fewer pixels
				const uint32_t* src_block = reinterpret_cast<const uint32_t*>(src_line);

				int remaining = pixels_to_process;
				int chunk = 0;

				while (remaining > 0)
				{
					const uint32_t* chunk_ptr = src_block + chunk * 4;

					// Extract values as above
					uint32_t word0 = chunk_ptr[0];
					uint32_t word1 = chunk_ptr[1];
					uint32_t word2 = chunk_ptr[2];
					uint32_t word3 = chunk_ptr[3];

					// Extract Y, U, V values the same way as above
					uint16_t y_values[6];
					y_values[0] = ((word0) & 0x3FF) << 6;
					y_values[1] = ((word0 >> 20) & 0x3FF) << 6;
					y_values[2] = ((word1 >> 10) & 0x3FF) << 6;
					y_values[3] = ((word2)) & 0x3FF << 6;
					y_values[4] = ((word2 >> 20) & 0x3FF) << 6;
					y_values[5] = ((word3 >> 10) & 0x3FF) << 6;

					uint16_t u_values[3];
					u_values[0] = ((word0 >> 10) & 0x3FF) << 6;
					u_values[1] = ((word1 >> 20) & 0x3FF) << 6;
					u_values[2] = ((word3)) & 0x3FF << 6;

					uint16_t v_values[3];
					v_values[0] = ((word1)) & 0x3FF << 6;
					v_values[1] = ((word2 >> 10) & 0x3FF) << 6;
					v_values[2] = ((word3 >> 20) & 0x3FF) << 6;

					// Store only within bounds
					for (int i = 0; i < 6 && i < remaining; i++)
					{
						dst_y[x + chunk * 6 + i] = y_values[i];
					}

					for (int i = 0; i < 3 && i * 2 < remaining; i++)
					{
						dst_u[(x + chunk * 6 + i * 2) / 2] = u_values[i];
						dst_v[(x + chunk * 6 + i * 2) / 2] = v_values[i];
					}

					remaining -= 6;
					chunk++;
				}
			}

			// Move to next block of pixels
			src_line += v210_chunk_size;
		}
	}
}

// Function to allocate P210 planes from V210 source
static void allocate_and_convert_v210_to_p210(const uint8_t* v210_data, uint16_t** y_plane,
                                              uint16_t** u_plane, uint16_t** v_plane,
                                              int width, int height, int v210_stride)
{
	// Allocate memory for the P210 planes
	*y_plane = static_cast<uint16_t*>(_aligned_malloc(width * height * sizeof(uint16_t), 32));
	*u_plane = static_cast<uint16_t*>(_aligned_malloc((width / 2) * height * sizeof(uint16_t), 32));
	*v_plane = static_cast<uint16_t*>(_aligned_malloc((width / 2) * height * sizeof(uint16_t), 32));

	if (!*y_plane || !*u_plane || !*v_plane)
	{
		// Clean up if allocation failed
		if (*y_plane) _aligned_free(*y_plane);
		if (*u_plane) _aligned_free(*u_plane);
		if (*v_plane) _aligned_free(*v_plane);

		*y_plane = *u_plane = *v_plane = nullptr;
		return;
	}

	convert_v210_to_p210_avx2(v210_data, *y_plane, *u_plane, *v_plane, width, height, v210_stride);
}

void convert_v210_p210(IDeckLinkVideoInputFrame* frame, uint16_t** yPlane, uint16_t** uPlane, uint16_t** vPlane)
{
	auto width = frame->GetWidth();

	int v210_pixels_per_macroblock = 6;
	int v210_bytes_per_macroblock = 16;
	int v210_macroblocks_per_row = (width + v210_pixels_per_macroblock - 1) / v210_pixels_per_macroblock;
	int v210_stride = v210_macroblocks_per_row * v210_bytes_per_macroblock;

	CComQIPtr<IDeckLinkVideoBuffer> vb = frame;
	vb->StartAccess(bmdBufferAccessRead);
	void* sourceData;
	vb->GetBytes(&sourceData);

	uint8_t* v210Bytes = static_cast<uint8_t*>(sourceData);
	allocate_and_convert_v210_to_p210(v210Bytes, yPlane, uPlane, vPlane, width, frame->GetHeight(), v210_stride);

	vb->EndAccess(bmdBufferAccessRead);
}
